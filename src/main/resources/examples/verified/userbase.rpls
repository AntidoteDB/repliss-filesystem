// application implementation:

def registerUser(name: String, mail: String): UserId {
  var u: UserId
  atomic {
    u = new UserId
    call user(update(u, name(assign(name))))
    call user(update(u, mail(assign(mail))))
  }
  return u
}

def updateMail(id: UserId, newMail: String) {
  atomic {
    if (user(containsKey(id))) {
      call user(update(id, mail(assign(newMail))))
    }
  }
}

def removeUser(id: UserId) {
  call user(delete(id))
}

def getUser(id: UserId): getUserResult {
  atomic {
    if (user(containsKey(id))) {
      return found(user(read(id, name(get()))), user(read(id, mail(get()))))
    } else {
      return notFound()
    }
  }
}

// used types:

idtype UserId
type String

type getUserResult =
    notFound()
  | found(name: String, mail: String)

// CRDT specifications
crdt user: Map_dw[UserId, {
    name: Register[String],
    mail: Register[String]
}]


// application specification:

invariant (forall r: invocationId, g: invocationId, u: UserId  ::
     r.info == removeUser(u)
  && g.info == getUser(u)
  && r happened before g
  ==> g.result == getUser_res(notFound()))

// additional invariants:
invariant forall u: UserId, i: invocationId :: i.info == removeUser(u) && i.result != NoResult()
  ==> exists c: callId :: c.origin == i

invariant forall u: UserId, i: invocationId, c: callId ::
     i.info == removeUser(u)
  && c.origin == i
  ==> c.op == user(delete(u))





invariant !(exists write: callId, delete: callId,
                   u: UserId, v: String ::
       (write.op == user(update(u, mail(assign(v)))) || write.op == user(update(u, name(assign(u, v)))))
    && delete.op == user(delete(u))
    && delete happened before write)



