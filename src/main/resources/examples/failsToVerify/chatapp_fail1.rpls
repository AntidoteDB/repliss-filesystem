def sendMessage(from: UserId, content: String): MessageId {
    var m: MessageId
    atomic {
        m = new MessageId
        call message_author_assign(m, from)
        call message_content_assign(m, content)
        call chat_add(m)
    }
    return m
}

def editMessage(id: MessageId, newContent: String) {
    atomic {
        if (message_exists(id)) {
            call message_content_assign(id, newContent)
        }
    }
}

def deleteMessage(message_id: MessageId) {
    atomic {
        if (message_exists(message_id)) {
            call chat_remove(message_id)
            call message_delete(message_id)
        }
    }
}


def getMessage(m: MessageId): getMessageResult {
    atomic {
        if (message_exists(m)) {
            return found(message_author_get(m), message_content_getFirst(m))
        } else {
            return notFound()
        }
    }
}


type getMessageResult =
    notFound()
  | found(author: UserId, content: String)

type UserId
idtype MessageId
type String

crdt chat: Set_aw[MessageId]

crdt message: Map_uw[MessageId, {
    author: Register[UserId],
    content: MultiValueRegister[String]
}]

// integrity constraint:
invariant forall m: MessageId ::
    chat_contains(m) ==> message_exists(m)


// getMessage returns correct authors
invariant (forall g: invocationId, m: MessageId, author: UserId, content: String ::
     g.info == getMessage(m)
  && g.result == getMessage_res(found(author, content))
  ==> (exists s: invocationId, content2: String :: s.info == sendMessage(author, content2)))

