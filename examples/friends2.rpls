idtype UserId

def makeFriends(userA: UserId, userB: UserId) {
  atomic {
    call friendSet_add(userA, userB)
    call friendSet_add(userB, userA)
  }
}

//def unFriend(userA: UserId, userB: UserId) {
//  atomic {
//    call friendSet_remove(userA, userB)
//    call friendSet_remove(userB, userA)
//  }
//}

// each user has a set of friends
operation friendSet_add(key: UserId, value: UserId)
operation friendSet_remove(key: UserId, value: UserId)

@inline query friendSet_contains(key: UserId, value: UserId): boolean =
  (exists c1: callId ::
         c1 is visible
      && c1.op == friendSet_add(key, value)
      && (forall c2: callId :: (c2 is visible && c2.op == friendSet_remove(key, value)) ==> c2 happened before c1))

// gset-semantics
//@inline query friendSet_contains(key: UserId, value: UserId): boolean =
//  (exists c1: callId ::
//         c1 is visible
//      && c1.op == friendSet_add(key, value))

// friendship relation should be symmetric
invariant forall a: UserId, b: UserId ::
  friendSet_contains(a, b) ==> friendSet_contains(b, a)



//invariant forall a: UserId, b: UserId, ca1: callId ::
//         ca1 is visible
//      && ca1.op == friendSet_add(a, b)
//      && (forall ca2: callId :: (ca2 is visible && ca2.op == friendSet_remove(a, b)) ==> ca2 happened before ca1)
//      ==> (exists cb1: callId ::
//              cb1 is visible
//           && sameTransaction(ca1, cb1)
//           && cb1.op == friendSet_add(b, a)
//           && (forall cb2: callId :: (cb2 is visible && cb2.op == friendSet_remove(b, a)) ==> cb2 happened before cb1))


invariant forall a: UserId, b: UserId, c1: callId ::
    c1.op == friendSet_add(a, b)
  ==> (exists c2: callId ::
        c2.op == friendSet_add(b, a)
        && sameTransaction(c1,c2))

invariant forall a: UserId, b: UserId, c1: callId ::
    c1.op == friendSet_remove(a, b)
  ==> (exists c2: callId ::
        c2.op == friendSet_remove(b, a)
        && sameTransaction(c1,c2))

invariant forall a: UserId, b: UserId, c1: callId, c2: callId ::
       c1.op == friendSet_add(a, b)
    && c2.op == friendSet_remove(a, b)
    ==> !sameTransaction(c1,c2)

// TODO same thing as above for removes

// property that only adds or only removes are together in one transaction


// no removes yet (TODO):
//invariant forall c1: callId, a: UserId, b: UserId ::
//  c1.op != friendSet_remove(a, b)
